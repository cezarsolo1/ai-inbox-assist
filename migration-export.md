# Complete Supabase Project Migration Script

## Overview
This script recreates the entire database schema, functions, policies, and edge functions for a ticket management and messaging system with email/WhatsApp integration.

## Step 1: Create Custom Types

```sql
-- Create custom types
CREATE TYPE public.user_role AS ENUM ('admin', 'tenant');
```

## Step 2: Create Tables

### Core Tables

```sql
-- Tenants table
CREATE TABLE public.tenants (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- User roles table
CREATE TABLE public.user_roles (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL,
    role user_role DEFAULT 'tenant'::user_role NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);

-- Email threads table
CREATE TABLE public.email_threads (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    subject text NOT NULL,
    participant_email text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Email messages table
CREATE TABLE public.email_messages (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    thread_id uuid NOT NULL,
    direction text NOT NULL,
    from_email text NOT NULL,
    to_email text NOT NULL,
    body text,
    attachments jsonb DEFAULT '[]'::jsonb NOT NULL,
    seen boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Inbox messages table
CREATE TABLE public.inbox_messages (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    channel text NOT NULL,
    from_msisdn text NOT NULL,
    to_msisdn text NOT NULL,
    body text,
    profile_name text,
    twilio_sid text,
    media jsonb DEFAULT '[]'::jsonb,
    raw jsonb,
    seen boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Outbound messages table  
CREATE TABLE public.outbound_messages (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    channel text DEFAULT 'whatsapp'::text NOT NULL,
    from_msisdn text NOT NULL,
    to_msisdn text NOT NULL,
    body text NOT NULL,
    media jsonb DEFAULT '[]'::jsonb NOT NULL,
    status text DEFAULT 'queued'::text NOT NULL,
    twilio_sid text,
    error text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

-- Tickets table
CREATE TABLE public.tickets (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    tenant_id uuid,
    title text NOT NULL,
    description text,
    category text DEFAULT 'general'::text NOT NULL,
    priority text DEFAULT 'medium'::text NOT NULL,
    status text DEFAULT 'open'::text NOT NULL,
    property_address text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);
```

## Step 3: Create Views

```sql
-- Conversation messages view
CREATE VIEW public.conversation_messages AS
SELECT 
    im.id,
    'inbound'::text AS direction,
    im.channel,
    im.from_msisdn AS counterparty,
    im.to_msisdn AS our_number,
    im.body,
    im.twilio_sid,
    im.media,
    im.created_at,
    NULL::text AS status
FROM public.inbox_messages im

UNION ALL

SELECT 
    om.id,
    'outbound'::text AS direction,
    om.channel,
    om.to_msisdn AS counterparty,
    om.from_msisdn AS our_number,
    om.body,
    om.twilio_sid,
    om.media,
    om.created_at,
    om.status
FROM public.outbound_messages om
ORDER BY created_at;
```

## Step 4: Create Functions

```sql
-- Get user role function
CREATE OR REPLACE FUNCTION public.get_user_role(user_uuid uuid)
RETURNS user_role
LANGUAGE sql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
    SELECT role FROM public.user_roles 
    WHERE user_id = user_uuid 
    LIMIT 1;
$function$;

-- Check if user has role
CREATE OR REPLACE FUNCTION public.has_role(_user_id uuid, _role user_role)
RETURNS boolean
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path TO 'public'
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id
      AND role = _role
  )
$function$;

-- Set user role (admin only)
CREATE OR REPLACE FUNCTION public.set_user_role(user_uuid uuid, new_role user_role)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
BEGIN
    -- Check if caller is admin
    IF NOT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_id = auth.uid() 
        AND role = 'admin'
    ) THEN
        RAISE EXCEPTION 'Only admins can set user roles';
    END IF;
    
    -- Insert or update user role
    INSERT INTO public.user_roles (user_id, role)
    VALUES (user_uuid, new_role)
    ON CONFLICT (user_id, role) DO NOTHING;
    
    -- Remove other roles for this user
    DELETE FROM public.user_roles 
    WHERE user_id = user_uuid 
    AND role != new_role;
END;
$function$;

-- Get users with roles (admin only)
CREATE OR REPLACE FUNCTION public.get_users_with_roles()
RETURNS TABLE(id uuid, email text, role user_role, created_at timestamp with time zone)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
BEGIN
    -- Check if caller is admin
    IF NOT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_id = auth.uid() 
        AND role = 'admin'
    ) THEN
        RAISE EXCEPTION 'Only admins can view all users';
    END IF;
    
    -- Return users with their roles
    RETURN QUERY
    SELECT 
        ur.user_id as id,
        COALESCE(au.email, 'Unknown User') as email,
        ur.role,
        ur.created_at
    FROM public.user_roles ur
    LEFT JOIN auth.users au ON au.id = ur.user_id
    ORDER BY ur.created_at DESC;
END;
$function$;

-- Handle new user registration
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
BEGIN
  INSERT INTO public.user_roles (user_id, role)
  VALUES (new.id, 'tenant');
  RETURN new;
END;
$function$;

-- Update tickets timestamp
CREATE OR REPLACE FUNCTION public.update_tickets_updated_at()
RETURNS trigger
LANGUAGE plpgsql
SET search_path TO 'public'
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$;

-- Validate inbox message updates
CREATE OR REPLACE FUNCTION public.inbox_messages_validate_update()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO ''
AS $function$
BEGIN
  -- If anon role, only allow changing the 'seen' column
  IF auth.role() = 'anon' THEN
    IF (NEW IS DISTINCT FROM OLD) THEN
      -- Check if only 'seen' field is being updated
      IF (
        NEW.id           IS DISTINCT FROM OLD.id OR
        NEW.channel      IS DISTINCT FROM OLD.channel OR
        NEW.from_msisdn  IS DISTINCT FROM OLD.from_msisdn OR
        NEW.to_msisdn    IS DISTINCT FROM OLD.to_msisdn OR
        NEW.body         IS DISTINCT FROM OLD.body OR
        NEW.profile_name IS DISTINCT FROM OLD.profile_name OR
        NEW.twilio_sid   IS DISTINCT FROM OLD.twilio_sid OR
        NEW.media        IS DISTINCT FROM OLD.media OR
        NEW.raw          IS DISTINCT FROM OLD.raw OR
        NEW.created_at   IS DISTINCT FROM OLD.created_at
      ) THEN
        RAISE EXCEPTION 'Only the seen field can be updated by anon role';
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$function$;

-- Validate email message updates
CREATE OR REPLACE FUNCTION public.email_messages_validate_update()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO ''
AS $function$
begin
  if auth.role() = 'anon' then
    if (new is distinct from old) then
      if (
        new.id          is distinct from old.id or
        new.thread_id   is distinct from old.thread_id or
        new.direction   is distinct from old.direction or
        new.from_email  is distinct from old.from_email or
        new.to_email    is distinct from old.to_email or
        new.body        is distinct from old.body or
        new.attachments is distinct from old.attachments or
        new.created_at  is distinct from old.created_at
      ) then
        raise exception 'Only the seen field can be updated by anon role';
      end if;
    end if;
  end if;
  return new;
end;
$function$;
```

## Step 5: Enable Row Level Security

```sql
-- Enable RLS on all tables
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.inbox_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.outbound_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;
```

## Step 6: Create RLS Policies

```sql
-- User roles policies
CREATE POLICY "Users can view their own roles" ON public.user_roles
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage all roles" ON public.user_roles
FOR ALL USING ((auth.jwt() ->> 'role'::text) = 'service_role'::text);

CREATE POLICY "Admins can manage all roles" ON public.user_roles
FOR ALL USING (EXISTS (
  SELECT 1 FROM user_roles ur
  WHERE ur.user_id = auth.uid() AND ur.role = 'admin'::user_role
));

-- Tenants policies
CREATE POLICY "Allow anon to read tenants" ON public.tenants
FOR SELECT USING (true);

-- Email threads policies
CREATE POLICY "Allow public read access to email threads" ON public.email_threads
FOR SELECT USING (true);

CREATE POLICY "Service role can insert threads" ON public.email_threads
FOR INSERT WITH CHECK (true);

CREATE POLICY "Service role can update threads" ON public.email_threads
FOR UPDATE USING (true) WITH CHECK (true);

CREATE POLICY "Service role can delete threads" ON public.email_threads
FOR DELETE USING (true);

-- Email messages policies
CREATE POLICY "Allow public read access to email messages" ON public.email_messages
FOR SELECT USING (true);

CREATE POLICY "Allow public update of seen status on email messages" ON public.email_messages
FOR UPDATE USING (true) WITH CHECK (true);

CREATE POLICY "Service role can insert messages" ON public.email_messages
FOR INSERT WITH CHECK (true);

CREATE POLICY "Service role can update messages" ON public.email_messages
FOR UPDATE USING (true) WITH CHECK (true);

CREATE POLICY "Service role can delete messages" ON public.email_messages
FOR DELETE USING (true);

-- Inbox messages policies
CREATE POLICY "Allow public read access to inbox messages" ON public.inbox_messages
FOR SELECT USING (true);

CREATE POLICY "Allow public update of seen status on inbox messages" ON public.inbox_messages
FOR UPDATE USING (true) WITH CHECK (true);

CREATE POLICY "Service role can insert messages" ON public.inbox_messages
FOR INSERT WITH CHECK (true);

CREATE POLICY "Service role can update messages" ON public.inbox_messages
FOR UPDATE USING (true) WITH CHECK (true);

CREATE POLICY "Service role can delete messages" ON public.inbox_messages
FOR DELETE USING (true);

CREATE POLICY "Authenticated users can delete inbox messages" ON public.inbox_messages
FOR DELETE USING (true);

-- Outbound messages policies
CREATE POLICY "Allow public read access to outbound messages" ON public.outbound_messages
FOR SELECT USING (true);

CREATE POLICY "Authenticated users can insert outbound messages" ON public.outbound_messages
FOR INSERT WITH CHECK (true);

CREATE POLICY "Authenticated users can update outbound messages" ON public.outbound_messages
FOR UPDATE USING (true) WITH CHECK (true);

CREATE POLICY "Authenticated users can delete outbound messages" ON public.outbound_messages
FOR DELETE USING (true);

-- Tickets policies
CREATE POLICY "Allow public read access to tickets" ON public.tickets
FOR SELECT USING (true);

CREATE POLICY "Tenants can create their own tickets" ON public.tickets
FOR INSERT WITH CHECK (auth.uid() = tenant_id);

CREATE POLICY "Tenants can update their own tickets" ON public.tickets
FOR UPDATE USING (auth.uid() = tenant_id);
```

## Step 7: Create Triggers

```sql
-- Trigger for new user registration
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();

-- Trigger for tickets updated_at
CREATE TRIGGER update_tickets_updated_at
    BEFORE UPDATE ON public.tickets
    FOR EACH ROW
    EXECUTE FUNCTION public.update_tickets_updated_at();

-- Trigger for inbox messages validation
CREATE TRIGGER inbox_messages_validate_update_trigger
    BEFORE UPDATE ON public.inbox_messages
    FOR EACH ROW
    EXECUTE FUNCTION public.inbox_messages_validate_update();

-- Trigger for email messages validation
CREATE TRIGGER email_messages_validate_update_trigger
    BEFORE UPDATE ON public.email_messages
    FOR EACH ROW
    EXECUTE FUNCTION public.email_messages_validate_update();
```

## Step 8: Insert Sample Data

```sql
-- Insert sample tickets
INSERT INTO public.tickets (tenant_id, title, description, category, priority, status, property_address) VALUES
(gen_random_uuid(), 'Broken Air Conditioning', 'The AC unit in the living room is not working properly', 'maintenance', 'high', 'open', '123 Main St, Apt 4B'),
(gen_random_uuid(), 'Lease Renewal Request', 'Tenant wants to renew lease for another year', 'administrative', 'medium', 'pending', '456 Oak Ave, Unit 2A'),
(gen_random_uuid(), 'Water Leak in Kitchen', 'There is a water leak under the kitchen sink', 'maintenance', 'high', 'in_progress', '789 Pine Rd, House'),
(gen_random_uuid(), 'Parking Permit Application', 'New tenant needs parking permit for visitor', 'administrative', 'low', 'resolved', '321 Elm St, Apt 1C'),
(gen_random_uuid(), 'Heating System Maintenance', 'Annual heating system check and maintenance', 'maintenance', 'medium', 'open', '654 Maple Dr, Unit 3B'),
(gen_random_uuid(), 'Security Deposit Return', 'Processing security deposit return for moved-out tenant', 'financial', 'medium', 'pending', '987 Cedar Ln, Apt 2D'),
(gen_random_uuid(), 'Appliance Replacement', 'Refrigerator needs to be replaced due to age', 'maintenance', 'medium', 'in_progress', '147 Birch St, House'),
(gen_random_uuid(), 'Rent Payment Issue', 'Tenant having trouble with online rent payment system', 'financial', 'high', 'open', '258 Willow Ave, Unit 1A'),
(gen_random_uuid(), 'Pet Policy Question', 'Tenant inquiring about pet policy and fees', 'general', 'low', 'resolved', '369 Spruce Ct, Apt 3C'),
(gen_random_uuid(), 'Smoke Detector Battery', 'Smoke detector beeping - needs battery replacement', 'maintenance', 'medium', 'open', '741 Aspen Way, Unit 2B'),
(gen_random_uuid(), 'Late Rent Notice', 'Tenant is 5 days late on rent payment', 'financial', 'high', 'pending', '852 Poplar St, Apt 1D'),
(gen_random_uuid(), 'Move-in Inspection', 'Schedule move-in inspection for new tenant', 'administrative', 'medium', 'in_progress', '963 Chestnut Ave, House');
```

## Required Secrets

Add these secrets in your Supabase project settings:

- `OPENAI_API_KEY` - For AI functionality
- `GMAIL_CLIENT_ID` - For Gmail integration  
- `GMAIL_CLIENT_SECRET` - For Gmail integration
- `GMAIL_REFRESH_TOKEN` - For Gmail authentication
- `WEBHOOK_SECRET` - For secure webhook handling

## Edge Functions

The project includes several edge functions that need to be created:

1. `ai-draft-reply` - AI-powered reply generation
2. `email-inbox-intake` - Email processing
3. `email-delete-message` - Email message deletion
4. `generate-tenant-reply` - Tenant-specific AI replies
5. `inbox-intake` - Message intake processing
6. `send-email` - Email sending
7. `send-whatsapp` - WhatsApp message sending

## Frontend Integration

The frontend uses:
- React with TypeScript
- Supabase client for database operations
- React Query for data fetching
- Shadcn/UI components
- Tailwind CSS for styling

Key features:
- Ticket management with Kanban board
- Email thread management
- WhatsApp/SMS conversation handling
- User authentication and role management
- Real-time updates via Supabase subscriptions

## Notes

- All database operations use RLS for security
- The system supports both email and WhatsApp/SMS messaging
- Tickets can be managed with drag-and-drop Kanban interface
- User roles determine access permissions (admin vs tenant)
- Real-time features enabled through Supabase subscriptions